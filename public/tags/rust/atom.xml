<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title>nickmonad - rust</title>
    <link rel="self" type="application/atom+xml" href="https://nickmonad.blog/tags/rust/atom.xml"/>
    <link rel="alternate" type="text/html" href="https://nickmonad.blog"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2023-08-31T00:00:00+00:00</updated>
    <id>https://nickmonad.blog/tags/rust/atom.xml</id>
    <entry xml:lang="en">
        <title>Building a nostr client [1]</title>
        <published>2023-08-31T00:00:00+00:00</published>
        <updated>2023-08-31T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Nick Miller
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://nickmonad.blog/2023/building-nostr-client-index-1/"/>
        <id>https://nickmonad.blog/2023/building-nostr-client-index-1/</id>
        
        <content type="html" xml:base="https://nickmonad.blog/2023/building-nostr-client-index-1/">&lt;p&gt;Welcome to the second installation of the &quot;Building a nostr client&quot; series. The goal of this series is to walk through
building a simple nostr client in Rust. If you haven&#x27;t seen the first post &lt;a href=&quot;https:&#x2F;&#x2F;nickmonad.blog&#x2F;2023&#x2F;building-nostr-client-index-0&#x2F;&quot;&gt;here&lt;&#x2F;a&gt;,
I would recommend doing so, as we&#x27;ll build on those concepts. Also, if you aren&#x27;t familiar with nostr and why I&#x27;m doing this,
that would be a good place to start as well!&lt;&#x2F;p&gt;
&lt;p&gt;In the last post we discussed the basic data structures of the protocol; how to build them, and what basic Event signing
could look like.&lt;&#x2F;p&gt;
&lt;p&gt;In this post, I want to start connecting to relays, and build a simple TUI (terminal user interface) to display events.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;building-on-prior-art&quot;&gt;Building on prior art...&lt;&#x2F;h3&gt;
&lt;p&gt;When I first considered doing this series of posts, I had the thought that I would do pretty much everything
&quot;from scratch&quot;. Essentially, use libraries available to me in Rust, but nothing nostr specific. After finding the
&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;nostr&#x2F;latest&#x2F;nostr&#x2F;index.html&quot;&gt;nostr crate&lt;&#x2F;a&gt; and giving it some thought, I decided that I would, at the very least,
use its core data structures, event generation and signing capabilities to build my client. &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;yukibtc&quot;&gt;yukibtc&lt;&#x2F;a&gt;
and other contributors have done an incredible job with this crate so far. Much better than I could do. It&#x27;s easy
to understand and quite comprehensive.&lt;&#x2F;p&gt;
&lt;p&gt;So, in the interest of time, and future-proofing this project (I know I&#x27;d have to refactor my code to use the &lt;code&gt;nostr&lt;&#x2F;code&gt;
crate at some point anyway), I&#x27;ll be using that crate moving forward. Even so, I want to explore some different methods
of relay interaction that depart from the sibling &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;nostr-sdk&#x2F;latest&#x2F;nostr_sdk&#x2F;index.html&quot;&gt;nostr-sdk&lt;&#x2F;a&gt;
crate, so we&#x27;ll have plenty of code to write there.&lt;&#x2F;p&gt;
&lt;p&gt;Moving on!&lt;&#x2F;p&gt;
&lt;h3 id=&quot;relays&quot;&gt;Relays&lt;&#x2F;h3&gt;
&lt;p&gt;Relays are the backbone of the nostr protocol. They are responsible for accepting events and sending them on to
interested clients. By design, there are many relays a client could possibly connect to. Some require payment for access,
but many are free. Some are built for a specific community or topic in mind, but most right now seem to be pretty
free-form. If one relay goes down, for any reason, temporarily or permanently, clients can just connect to another.&lt;&#x2F;p&gt;
&lt;p&gt;Clients connect to relays and send events (or &quot;notes&quot;) across them, and clients on the other end set up &lt;em&gt;filters&lt;&#x2F;em&gt;
for those events. Not every user is automatically connected to every other user, as they would be on the global
feed of a centralized platform, so there are some issues around discovery, as you need to know which relays
people are posting to. But, in practice, it&#x27;s not a big deal. (And there are some NIPs out there attempting to mitigate this.)&lt;&#x2F;p&gt;
&lt;p&gt;As you start to think about how a client should interact with its configured relays, you tend to realize:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;There is no &quot;should&quot;.&lt;&#x2F;strong&gt; Other than the basic data over-the-wire requirements of the protocol, clients can and actively do
all sorts of things to transmit and receive events to and from relays. Without &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;twitter&#x2F;the-algorithm&quot;&gt;The Algorithm&lt;&#x2F;a&gt;
handed down from on high, there are really no rules here. You want events chronologically? Great. You want events from your
followed accounts and the accounts they follow? Sure. Only show events whose ID ends with the hex digit &lt;code&gt;f&lt;&#x2F;code&gt;? I guess.
Allow the user to selectively send events to some relays but not others? Yes, absolutely.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;It&#x27;s suprisingly deep.&lt;&#x2F;strong&gt; There are a lot of practical elements to consider when building a client&#x27;s view
of the nostr world, especially in a &quot;twitter-like&quot; way. Generally you want to have the option of viewing something other than the &quot;global&quot; feed
of all their connected relays, as it can either be extremely spammy, or just too much information, too quickly. So,
you need some kind of view filtering, even if it&#x27;s just showing events from the user&#x27;s followed accounts. Also, what if the user
is away from the client for a while (say a month) and decides to come back? Do you start showing them events from exactly
where they left off? It might take them a while to scroll through and catch up to current events. Do you fetch older events
if they scroll in reverse chronological order? How many do you fetch at a time?&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;I could go on with plenty more rhetorical questions related to client&#x2F;relay interaction. It really is the wild west
right now and there are a lot of opportunities to innovate in this space.&lt;&#x2F;p&gt;
&lt;p&gt;All that being said, I want to start as simple as possible. For now, we will support showing events from the user&#x27;s
followed accounts, in the order we receive them. But first, we need to connect to some relays.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;finding-a-connection-3&quot;&gt;Finding a connection &amp;lt;3&lt;&#x2F;h4&gt;
&lt;p&gt;Connecting to a relay is &lt;em&gt;relatively&lt;&#x2F;em&gt; straightforward in principle, but somewhat difficult to manage in practice.&lt;&#x2F;p&gt;
&lt;p&gt;Fortunately, the really low-level details are already handled for us in a crate called
&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;tokio-tungstenite&#x2F;latest&#x2F;tokio_tungstenite&#x2F;index.html&quot;&gt;tokio-tungstenite&lt;&#x2F;a&gt;. &lt;code&gt;tungstenite&lt;&#x2F;code&gt; is a popular
Rust crate for handling &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;WebSockets_API&quot;&gt;WebSocket&lt;&#x2F;a&gt; connections, which
nostr uses for its protocol communication layer. The &quot;tokio&quot; side of this crate just brings it into the
most popular ecosystem for asynchronous programming in Rust... &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;tokio.rs&#x2F;&quot;&gt;tokio&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;I believe the primary motivating factor for using WebSockets in nostr instead of some other transport protocol
is that WebSockets are &lt;em&gt;everywhere&lt;&#x2F;em&gt;, especially modern web browsers. This means clients can work within
or (in our case) outside a browser context. It also means clients can make one connection to a relay, and reuse that
same connection for multiple things, reducing some of the connection overhead on the server.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Another quick caveat: Like many aspects of this series, especially related to Rust, I certainly cannot do the asynchronous programming
story justice here. It&#x27;s another huge topic, deserving of near book-length treatments itself. Very simply put,
asynchronous programming allows applications that primarily do I&#x2F;O to scale quite far, with fewer resources.
This is because I&#x2F;O related tasks generally take waaaay longer than the tasks a CPU must perform, due to the high
latency of the I&#x2F;O device (disk, network, etc). Therefore, we can tell the asynchronous runtime we anticipate running
some long I&#x2F;O task, and that it can literally &lt;em&gt;wait&lt;&#x2F;em&gt; for that task to complete, &lt;em&gt;while another task on the CPU runs&lt;&#x2F;em&gt;,
typically on the same thread.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Essentially, we need to start a bunch of tasks that send and receive events from configured relays on their own time,
and have another task that is aggregating these events together in some way: de-duplicating them,
showing them to the user, saving them to disk, etc.&lt;&#x2F;p&gt;
&lt;p&gt;So, we need a way to spawn the async I&#x2F;O task for each relay we want to interact with, and then communicate with that task
using nifty little tools called &quot;channels&quot;. I&#x27;ll try to illustrate how this is going to look.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;architecture&quot;&gt;Architecture&lt;&#x2F;h4&gt;
&lt;p&gt;Relays are implemented as a Rust &lt;code&gt;struct&lt;&#x2F;code&gt; type, with a few properties. First, it must be configured with a WebSocket
URL, which is published by a relay operator, and is up to our client to store and use. Internally, a &lt;code&gt;Relay&lt;&#x2F;code&gt; must
also create and reference a &quot;channel&quot;, that is used by the client to communicate with it asynchronously. These are
&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;tokio&#x2F;latest&#x2F;tokio&#x2F;sync&#x2F;mpsc&#x2F;index.html&quot;&gt;&lt;code&gt;tokio::sync::mpsc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; channels (&lt;strong&gt;&quot;multiple producer, single
consumer&quot;&lt;&#x2F;strong&gt;), and aren&#x27;t exposed directly to the client, but is indirectly through a function interface, as illustrated
below. Relays are created in a &lt;code&gt;disconnected&lt;&#x2F;code&gt; state.&lt;&#x2F;p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img alt=&quot;nostr relay architecture disconnected&quot; src=&quot;..&#x2F;images&#x2F;nostr-relay-disconnected.png&quot;&#x2F;&gt;&lt;&#x2F;div&gt;
&lt;p&gt;These &quot;control&quot; messages are used to tell the relay to send us events that match a certain filter
(as defined by &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;nostr-protocol&#x2F;nips&#x2F;blob&#x2F;master&#x2F;01.md&quot;&gt;NIP-01&lt;&#x2F;a&gt;), publish our own events, or disconnect.
They must be sent over a channel that the &lt;code&gt;Relay&lt;&#x2F;code&gt; manages since there is an underlying async task that must listen for
events from the relay and be responsive.&lt;&#x2F;p&gt;
&lt;p&gt;But first, we have to actually connect to the relay with its WebSocket address, and receive those events from it. When we
call the &lt;code&gt;Relay::connect()&lt;&#x2F;code&gt; method, we use the &lt;code&gt;tungstenite&lt;&#x2F;code&gt; crate underneath to open a WebSocket connection, and spin
up an async task to handle the &quot;up&quot; stream (messages &lt;em&gt;to&lt;&#x2F;em&gt; the relay), and the &quot;down&quot; stream (messages &lt;em&gt;from&lt;&#x2F;em&gt; the relay).
These &quot;up&quot; and &quot;down&quot; handles are also part of a &lt;code&gt;Stream&lt;&#x2F;code&gt; construct that is well beyond the scope of this post, but for
our purposes, &quot;up&quot; is like a &lt;code&gt;mpsc::Sender&lt;&#x2F;code&gt; and &quot;down&quot; is like a &lt;code&gt;mpsc::Receiver&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img alt=&quot;nostr relay architecture connected&quot; src=&quot;..&#x2F;images&#x2F;nostr-relay-connected.png&quot;&#x2F;&gt;&lt;&#x2F;div&gt;
&lt;p&gt;These relay messages are written over the wire as &lt;code&gt;Message&lt;&#x2F;code&gt; types from the &lt;code&gt;tungstenite&lt;&#x2F;code&gt; crate, and are translated
from the &lt;code&gt;nostr::ClientMessage&lt;&#x2F;code&gt; and to &lt;code&gt;nostr::RelayMessage&lt;&#x2F;code&gt; types.&lt;&#x2F;p&gt;
&lt;p&gt;Lastly, we have to consider how it looks when there are multiple relays involved, as is expected within a nostr client.
When the &lt;code&gt;Relay::connect()&lt;&#x2F;code&gt; method is called, it expects to be given a &lt;code&gt;mpsc::Sender&lt;&#x2F;code&gt; side of a channel, which can
be cloned and given to &lt;em&gt;every&lt;&#x2F;em&gt; relay we are interested in. These &quot;producers&quot; will all funnel to one &quot;consumer&quot; (&lt;code&gt;mpsc::Receiver&lt;&#x2F;code&gt;),
which acts as our firehose of events coming from all relays we have a connection with. There&#x27;s nothing required about this,
it just makes it easier to deal with in a simple implementation like this one. We can treat all &lt;code&gt;Relay&lt;&#x2F;code&gt; structs as if they
were one big set of relays, producing a single stream of events.&lt;&#x2F;p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img alt=&quot;nostr relay architecture stream&quot; src=&quot;..&#x2F;images&#x2F;nostr-relay-stream.png&quot;&#x2F;&gt;&lt;&#x2F;div&gt;
&lt;p&gt;As far as technical implementation details, there&#x27;s a lot left to go over here. I think the best way to think about this
is you have an async task (&quot;thread&quot;) driving the inbound&#x2F;outbound connection with the WebSocket relay
itself, and another, at the client level, that is driving the state of the &lt;code&gt;Relay&lt;&#x2F;code&gt; struct, and that is why we need
to use async channels behind &lt;code&gt;Arc&amp;lt;Mutex&amp;lt;...&amp;gt;&amp;gt;&lt;&#x2F;code&gt; primitives, so they can be safely cloned and shared throughout the client as necessary.
The &lt;code&gt;Relay&lt;&#x2F;code&gt; struct is a effectively just a handle over a set of common data structures, making the initial connection and
shuffling data between this async task boundary.&lt;&#x2F;p&gt;
&lt;p&gt;With that, we have a &lt;em&gt;very&lt;&#x2F;em&gt; simple nostr client interacting with relays! Here is some sample output that just shows
us connected to two major public relays, sending a filter for all kind &lt;code&gt;1&lt;&#x2F;code&gt; events after the current timestamp. When the
user hits Ctrl-C, we disconnect from each relay and shutdown.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; RUST_LOG=info cargo run
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Compiling&lt;&#x2F;span&gt;&lt;span&gt; roostr v0.1.0 (&#x2F;var&#x2F;home&#x2F;nickmonad&#x2F;code&#x2F;nostr&#x2F;roostr)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Finished&lt;&#x2F;span&gt;&lt;span&gt; dev &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;[&lt;&#x2F;span&gt;&lt;span&gt;unoptimized + debuginfo&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;]&lt;&#x2F;span&gt;&lt;span&gt; target(s) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;in&lt;&#x2F;span&gt;&lt;span&gt; 3.07s
&lt;&#x2F;span&gt;&lt;span&gt;     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Running &lt;&#x2F;span&gt;&lt;span&gt;`&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;target&#x2F;debug&#x2F;roostr&lt;&#x2F;span&gt;&lt;span&gt;`
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;[2023-08-26T19:59:28Z&lt;&#x2F;span&gt;&lt;span&gt; WARN  roostr] relay sent non-event message: EndOfStoredEvents(SubscriptionId(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;51102577c2f141aa2a06a10d3c2106b5&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;))
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;[2023-08-26T19:59:28Z&lt;&#x2F;span&gt;&lt;span&gt; WARN  roostr] relay sent non-event message: EndOfStoredEvents(SubscriptionId(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;5854bf7126a9337f9c35ea55dfdd5227&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;))
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;[2023-08-26T19:59:43Z&lt;&#x2F;span&gt;&lt;span&gt; INFO  roostr] EventId(0x078495389530eff3f78e86dcb14095f4c10d0bc80e9b1f5f0fa9bdab7c8a3c45)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;[2023-08-26T19:59:45Z&lt;&#x2F;span&gt;&lt;span&gt; INFO  roostr] EventId(0x48627557bcac6d61d35946a74e5f3cf63a1057a0852b17f22d45bf530eaab8a3)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;[2023-08-26T19:59:46Z&lt;&#x2F;span&gt;&lt;span&gt; INFO  roostr] EventId(0xe5954fe675db03fc5f0a1b4ea5d19f8de6fbd2cbf4be670fbd145652387d5136)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;[2023-08-26T19:59:49Z&lt;&#x2F;span&gt;&lt;span&gt; INFO  roostr] EventId(0xfa9d99dc2e1a1e3c7c61dbb26d3929d1c0f82ec513d86403eb1790bcd6d1c25e)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;[2023-08-26T19:59:50Z&lt;&#x2F;span&gt;&lt;span&gt; INFO  roostr] EventId(0xf2fe94cf82fb3d6dc39811320d43a9cbd0e1eaeb04ff7fb0a03ddea983a4ec21)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;[2023-08-26T19:59:50Z&lt;&#x2F;span&gt;&lt;span&gt; INFO  roostr] EventId(0xf2fe94cf82fb3d6dc39811320d43a9cbd0e1eaeb04ff7fb0a03ddea983a4ec21)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;[2023-08-26T19:59:50Z&lt;&#x2F;span&gt;&lt;span&gt; INFO  roostr] EventId(0xe4410e2d3714de65f21aa494ec89fb9e38ec69c05402143c5395cfe0df4e81fb)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;[2023-08-26T19:59:53Z&lt;&#x2F;span&gt;&lt;span&gt; INFO  roostr] EventId(0x14b7f5f38998a93bb9dda045b72d55a3bab61bde4481b65c415e5503c61eb40c)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;[2023-08-26T19:59:53Z&lt;&#x2F;span&gt;&lt;span&gt; INFO  roostr] EventId(0x953c7bb5884b57b98f54ddf227a8b437c3e061525e29a132c69f7848085df218)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;[2023-08-26T19:59:55Z&lt;&#x2F;span&gt;&lt;span&gt; INFO  roostr] EventId(0x9f4a511bd1f6b02ccb4c4daea54a51b5daef6d78b126219fa234962efc5d8de7)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;[2023-08-26T20:00:03Z&lt;&#x2F;span&gt;&lt;span&gt; INFO  roostr] EventId(0x84fec22e2056751d54c323fa4ff6ac3217d352f6f73eff84779fa3f7e5d48291)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;[2023-08-26T20:00:07Z&lt;&#x2F;span&gt;&lt;span&gt; INFO  roostr] EventId(0xf7119e7250a7f6eaea5058254d850dcb7882428535f1aba1a3e511c5229aa00f)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;^C[2023-08-26T20:00:11Z&lt;&#x2F;span&gt;&lt;span&gt; WARN  roostr] shutting down!
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;[2023-08-26T20:00:11Z&lt;&#x2F;span&gt;&lt;span&gt; WARN  roostr::relay] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;[&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;wss:&#x2F;&#x2F;relay.damus.io&#x2F;&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;]&lt;&#x2F;span&gt;&lt;span&gt; user disconnect
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;[2023-08-26T20:00:11Z&lt;&#x2F;span&gt;&lt;span&gt; WARN  roostr::relay] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;[&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;wss:&#x2F;&#x2F;nostr-pub.wellorder.net&#x2F;&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;]&lt;&#x2F;span&gt;&lt;span&gt; user disconnect
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;blockquote&gt;
&lt;p&gt;The inital messages showing &lt;code&gt;EndOfStoredEvents&lt;&#x2F;code&gt; from each configured relay are due to the fact we set the &lt;code&gt;since&lt;&#x2F;code&gt;
value on our filter message to be &lt;code&gt;Timestamp::now()&lt;&#x2F;code&gt; and the relay is just saying, &quot;eveything after this will be in
real-time.&quot;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;tui&quot;&gt;TUI&lt;&#x2F;h3&gt;
&lt;p&gt;Now that we have events coming in from the relay, we can start on the real &lt;em&gt;client&lt;&#x2F;em&gt; functionality. As I stated earlier,
this can go really deep on implementation, and wide on feature set. I want to keep things really simple, so
it won&#x27;t do much for now.&lt;&#x2F;p&gt;
&lt;p&gt;To help set some direction on where to focus next, I think we can break it down like so:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;First, read a list of public keys to &quot;follow&quot; from a local config file.&lt;&#x2F;li&gt;
&lt;li&gt;Using the public keys present in that config, setup and send filters to each relay, asking first for kind &lt;code&gt;0&lt;&#x2F;code&gt; events
associated with the public key(s), giving us &quot;profile&quot; metadata, like the user&#x27;s preferred display name, followed by kind &lt;code&gt;1&lt;&#x2F;code&gt; events, the actual text notes,
from the past &lt;strong&gt;day&lt;&#x2F;strong&gt;. (Arbitrary choice.)&lt;&#x2F;li&gt;
&lt;li&gt;Listening on the aggregated event stream, use some kind of mechanism to ensure that events aren&#x27;t shown twice, in the case where
a followed public key is published to more than one of the relays we are interested in. This is quite common, and must be handled
by pretty much every client. There are really straightforward ways of handling this, using a list or map, but those come with tradeoffs
in performance and memory usage over time. We could use a SQLite based implemention, which I think would be ideal for a client like this,
but for now, let&#x27;s just use a simple in-memory set, and vector (list) of events.&lt;&#x2F;li&gt;
&lt;li&gt;Build a simple TUI (terminal user interface) for showing the events and navigating through the list.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;This is the simplest possible start I can imagine, while building something at least marginally useful. Many factors of a &quot;real&quot; client
won&#x27;t be considered here, but, it&#x27;ll be fun to continue adding features over time.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;starting-up&quot;&gt;Starting up&lt;&#x2F;h4&gt;
&lt;p&gt;First, we need to read our config file, and create our primary &lt;code&gt;mpsc&lt;&#x2F;code&gt; channels. One for that relay &quot;firehose&quot; mentioned
above, and another for terminal events (user input, resize notifications, etc). The first block here is our example
&lt;code&gt;config.toml&lt;&#x2F;code&gt; file.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;follow &lt;&#x2F;span&gt;&lt;span&gt;= [
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;npub180cvv07tjdrrgpa0j7j7tmnyl2yr6yr7l8j4s3evf6u64th6gkwsyjh6w6&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# fiatjaf
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;npub1sg6plzptd64u62a878hep2kev88swjh3tw00gjsfl8f237lmu63q0uf63m&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# jack
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;npub1qny3tkh0acurzla8x3zy4nhrjz5zd8l9sy9jys09umwng00manysew95gx&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# odell
&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[[relay]]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;url &lt;&#x2F;span&gt;&lt;span&gt;= &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;wss:&#x2F;&#x2F;relay.damus.io&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[[relay]]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;url &lt;&#x2F;span&gt;&lt;span&gt;= &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;wss:&#x2F;&#x2F;nostr-pub.wellorder.net&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;blockquote&gt;
&lt;p&gt;In the long term, the config for &lt;code&gt;roostr&lt;&#x2F;code&gt; would be more related to behavior, and not have hardcoded npubs
or relay URLs. These would be requested the first time a user started the client, and stored in a local database.
Pubkeys to follow would ideally come from nostr &lt;code&gt;kind:3&lt;&#x2F;code&gt; events, published via our user&#x27;s pubkey, but I decided
not to implement that right now, since we don&#x27;t have a database yet.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;tokio&lt;&#x2F;span&gt;&lt;span&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;main&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;main&lt;&#x2F;span&gt;&lt;span&gt;() -&amp;gt; anyhow::Result&amp;lt;()&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; send logs to stderr
&lt;&#x2F;span&gt;&lt;span&gt;    env_logger::builder().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;target&lt;&#x2F;span&gt;&lt;span&gt;(Target::Stderr).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;init&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; load config
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; config = Config::load(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;config.toml&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;).await?;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; event&#x2F;relay message bus
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;(tx, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; rx) = mpsc::channel::&amp;lt;RelayMessage&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1024&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; events from terminal
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;(events, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; input) = mpsc::channel::&amp;lt;TermEvent&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;10&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now, we can initialize our &lt;code&gt;Relay&lt;&#x2F;code&gt; structs, one for each URL we have listed in our configuration.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; filter for all kind:0 metadata objects
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; metadata = Filter::new()
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;(Kind::Metadata)
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;authors&lt;&#x2F;span&gt;&lt;span&gt;(config.follows.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;clone&lt;&#x2F;span&gt;&lt;span&gt;());
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; filter for all kind:1 notes
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; notes = Filter::new()
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;(Kind::TextNote)
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;authors&lt;&#x2F;span&gt;&lt;span&gt;(config.follows.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;clone&lt;&#x2F;span&gt;&lt;span&gt;())
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;since&lt;&#x2F;span&gt;&lt;span&gt;(Timestamp::now().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;sub&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;ONE_DAY&lt;&#x2F;span&gt;&lt;span&gt;)); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; statically defined `Duration` value
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; instantiate configured relays
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; relays: Vec&amp;lt;Relay&amp;gt; = vec![];
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; relay in config.relays {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; r = Relay::new(relay.url.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;clone&lt;&#x2F;span&gt;&lt;span&gt;());
&lt;&#x2F;span&gt;&lt;span&gt;        r.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;connect&lt;&#x2F;span&gt;&lt;span&gt;(tx.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;clone&lt;&#x2F;span&gt;&lt;span&gt;()).await?;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        r.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;send&lt;&#x2F;span&gt;&lt;span&gt;(ClientMessage::new_req(
&lt;&#x2F;span&gt;&lt;span&gt;            SubscriptionId::generate(),
&lt;&#x2F;span&gt;&lt;span&gt;            vec![metadata.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;clone&lt;&#x2F;span&gt;&lt;span&gt;(), notes.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;clone&lt;&#x2F;span&gt;&lt;span&gt;()],
&lt;&#x2F;span&gt;&lt;span&gt;        ))
&lt;&#x2F;span&gt;&lt;span&gt;        .await?;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        relays.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;push&lt;&#x2F;span&gt;&lt;span&gt;(r);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;processing-and-displaying-events&quot;&gt;Processing and displaying events&lt;&#x2F;h4&gt;
&lt;p&gt;Once the client has completed this initial startup, it can run its primary processing loop, reading events
from the relays, and user input from the terminal.&lt;&#x2F;p&gt;
&lt;p&gt;Since we aren&#x27;t using SQLite right now as we prove all this out, we&#x27;ll use an in-memory &quot;database&quot; structure.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Simple &amp;quot;database&amp;quot; implementation,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; storing a list of Events, and a map of Metadata objects, accessible via pubkey
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;derive&lt;&#x2F;span&gt;&lt;span&gt;(Default)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Database {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;events&lt;&#x2F;span&gt;&lt;span&gt;: Vec&amp;lt;Event&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;: HashMap&amp;lt;String, Metadata&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;metadata&lt;&#x2F;code&gt; attribute is important, as we want to show every pubkey&#x27;s &quot;username&quot; as they have published them
under the &lt;code&gt;kind:0&lt;&#x2F;code&gt; event. Since we have a filter setup for those, we can update this struct as a mapping between the
followed pubkeys and their metadata. The &lt;code&gt;events&lt;&#x2F;code&gt; attribute is a simple vector of all the &lt;code&gt;kind:1&lt;&#x2F;code&gt; events we receive.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Obviously, this isn&#x27;t really scalable for &quot;real-world&quot; usage. We&#x27;d ideally push these to a local SQLite file,
and maybe use these in-memory structures for a bounded cache. Just indefinitely growing this vector isn&#x27;t
efficient at all, but again, this is more of a proof-of-concept.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Finally, we can run our primary loop. Essentially, the client blocks while it waits for one of two types of
events: user input or relay events. For user events, the TUI will be given those events (other than the quit event),
and it will update its own state, like which nostr note is selected based on user selection.
For relay events, the database is updated. Incoming nostr events are de-duplicated, and then stored in the event list.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; setup our &amp;quot;database&amp;quot; and set of &amp;quot;seen&amp;quot; events, for de-duplication
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; database = Database::default();
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; seen: HashSet&amp;lt;EventId&amp;gt; = HashSet::new();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; setup tui
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; tui = Tui::new()?;
&lt;&#x2F;span&gt;&lt;span&gt;tui.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;events&lt;&#x2F;span&gt;&lt;span&gt;(events);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; initial draw
&lt;&#x2F;span&gt;&lt;span&gt;tui.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;draw&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;database);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; main event loop
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; as messages&#x2F;events come in, de-duplicate them
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; and store them for display on the UI
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    tokio::select! {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; get events from the terminal
&lt;&#x2F;span&gt;&lt;span&gt;        event = input.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;recv&lt;&#x2F;span&gt;&lt;span&gt;() =&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; event {
&lt;&#x2F;span&gt;&lt;span&gt;                Some(event) =&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;TermEvent::Key(KeyEvent{ code, .. }) = event {
&lt;&#x2F;span&gt;&lt;span&gt;                        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; code == KeyCode::Char(&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;q&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;) {
&lt;&#x2F;span&gt;&lt;span&gt;                            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; user quit - disconnect from relays
&lt;&#x2F;span&gt;&lt;span&gt;                            log::warn!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;[client] user quit!&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;);
&lt;&#x2F;span&gt;&lt;span&gt;                            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;disconnect&lt;&#x2F;span&gt;&lt;span&gt;(relays).await.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;                            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;break&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;                        }
&lt;&#x2F;span&gt;&lt;span&gt;                    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; pass event to TUI struct, so it can update its own state
&lt;&#x2F;span&gt;&lt;span&gt;                    tui.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;update&lt;&#x2F;span&gt;&lt;span&gt;(event, &amp;amp;database);
&lt;&#x2F;span&gt;&lt;span&gt;                },
&lt;&#x2F;span&gt;&lt;span&gt;                _ =&amp;gt; {}
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; get events from relay(s)
&lt;&#x2F;span&gt;&lt;span&gt;        msg = rx.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;recv&lt;&#x2F;span&gt;&lt;span&gt;() =&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; msg {
&lt;&#x2F;span&gt;&lt;span&gt;                Some(msg) =&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; msg {
&lt;&#x2F;span&gt;&lt;span&gt;                        RelayMessage::Event { event, .. } =&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;                            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; event.kind {
&lt;&#x2F;span&gt;&lt;span&gt;                                Kind::Metadata =&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;                                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; update metadata map, from pubkey to metadata
&lt;&#x2F;span&gt;&lt;span&gt;                                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; metadata = Metadata::from_json(&amp;amp;event.content).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;                                    database.metadata.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;insert&lt;&#x2F;span&gt;&lt;span&gt;(event.pubkey.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span&gt;(), metadata);
&lt;&#x2F;span&gt;&lt;span&gt;                                },
&lt;&#x2F;span&gt;&lt;span&gt;                                Kind::TextNote =&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;                                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; process note, ignore if we have seen already
&lt;&#x2F;span&gt;&lt;span&gt;                                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;!seen.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;contains&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;event.id) {
&lt;&#x2F;span&gt;&lt;span&gt;                                        database.events.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;push&lt;&#x2F;span&gt;&lt;span&gt;(event.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_ref&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;clone&lt;&#x2F;span&gt;&lt;span&gt;());
&lt;&#x2F;span&gt;&lt;span&gt;                                        seen.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;insert&lt;&#x2F;span&gt;&lt;span&gt;(event.id);
&lt;&#x2F;span&gt;&lt;span&gt;                                    }
&lt;&#x2F;span&gt;&lt;span&gt;                                }
&lt;&#x2F;span&gt;&lt;span&gt;                                _ =&amp;gt; {}
&lt;&#x2F;span&gt;&lt;span&gt;                            }
&lt;&#x2F;span&gt;&lt;span&gt;                        },
&lt;&#x2F;span&gt;&lt;span&gt;                        _ =&amp;gt; log::warn!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;relay sent non-event message: {:?}&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, msg)
&lt;&#x2F;span&gt;&lt;span&gt;                    }
&lt;&#x2F;span&gt;&lt;span&gt;                }
&lt;&#x2F;span&gt;&lt;span&gt;                None =&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;                    log::warn!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;all relay senders dropped&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;);
&lt;&#x2F;span&gt;&lt;span&gt;                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;break&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;                }
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; event(s) processed, draw another &amp;quot;frame&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;    tui.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;draw&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;database);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In both cases, after the event is processed, the TUI is re-drawn. In principle, there is some contention here. If there
is a delay in processing a relay event, user events will have to wait as they queue from the terminal input thread,
potentially causing a lag in the responsiveness. But, in practice, espcially in this case, the relay event processing
is so minimal, that it doesn&#x27;t have an impact. If there were heavier processing involved, the client would likely have
to split off that processing onto another async task or thread and signal its completion back to this thread.&lt;&#x2F;p&gt;
&lt;p&gt;As for the actual processing requirements and performance of re-drawing the TUI, we don&#x27;t have to worry about that
in practice either, since it&#x27;s just... outputing text to the terminal.&lt;&#x2F;p&gt;
&lt;p&gt;Since this post is already way too long, I&#x27;ll pass on explaining the actual TUI rendering in detail. Suffice it to
say, I chose to use &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;ratatui&#x2F;latest&#x2F;ratatui&#x2F;index.html&quot;&gt;ratatui&lt;&#x2F;a&gt;, the successor to &lt;code&gt;tui-rs&lt;&#x2F;code&gt;. It
provides really simple ways to put the terminal in the correct mode it needs to be in, and build up layout components.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;demo&quot;&gt;Demo!&lt;&#x2F;h3&gt;
&lt;blockquote&gt;
&lt;p&gt;This may not render correctly on mobile.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;script async id=&quot;asciicast-WvpaikA286wzkJ5RqBIIT6VzT&quot; src=&quot;https:&#x2F;&#x2F;asciinema.org&#x2F;a&#x2F;WvpaikA286wzkJ5RqBIIT6VzT.js&quot;&gt;&lt;&#x2F;script&gt;
&lt;p&gt;Look at that TUI &lt;strong&gt;magic!&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;next-up&quot;&gt;Next Up&lt;&#x2F;h3&gt;
&lt;p&gt;If you&#x27;ve stuck around this far, thanks for hanging in there. It took me way longer to publish this post than I wanted
it to take. It&#x27;s been a really busy summer - full of good and beautiful things, just not as much coding time outside of work.&lt;&#x2F;p&gt;
&lt;p&gt;There&#x27;s a lot that can still be done to make this TUI more functional, useful, and pretty. I think the first
thing I would do is make the rendered height of each note fixed and consistent, and allow the user to expand longer notes
if they want to read them. Since the terminal doesn&#x27;t have a &quot;continuous&quot; scrolling frame, like a fully graphical UI would
have, notes of different length can really break the rendering flow while scrolling through, as you can see in the demo.&lt;&#x2F;p&gt;
&lt;p&gt;But, for now, let&#x27;s move onto other things!&lt;&#x2F;p&gt;
&lt;p&gt;In the next (and likely final) installation of this series, I&#x27;ll add some basic key management, paving the way
for signing and publishing events.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Building a nostr client [0]</title>
        <published>2023-03-26T00:00:00+00:00</published>
        <updated>2023-03-26T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Nick Miller
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://nickmonad.blog/2023/building-nostr-client-index-0/"/>
        <id>https://nickmonad.blog/2023/building-nostr-client-index-0/</id>
        
        <content type="html" xml:base="https://nickmonad.blog/2023/building-nostr-client-index-0/">&lt;p&gt;Over the past few weeks, &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;nostr.how&#x2F;&quot;&gt;nostr&lt;&#x2F;a&gt; has continued to take much of my attention. I&#x27;m still
fascinated by this protocol and I&#x27;m very curious to see where it goes in the coming years.&lt;&#x2F;p&gt;
&lt;p&gt;If you haven&#x27;t heard of nostr yet, it stands for &quot;Notes and Other Stuff Transmitted over Relays&quot;, and is a pretty
simple, yet powerful, idea for defining and growing a social network. Instead of a centralized server (or even
federated servers that talk to each other) it uses the concept of &quot;relays&quot; that allow clients to connect to them and,
you guessed it, &lt;em&gt;transmit&lt;&#x2F;em&gt; &quot;notes&quot; and &quot;other stuff&quot;, using a cryptographic key pair to sign and verify that data.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;i&gt;By the way, how do people pronouce this thing? Is it &quot;nos-ter&quot;, &quot;nose-ter&quot;, ... something else? I tend towards the
first way for some reason.&lt;&#x2F;i&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;As the protocol&#x27;s &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;nostr-protocol&#x2F;nostr&quot;&gt;GitHub&lt;&#x2F;a&gt; states:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;The simplest open protocol that is able to create a censorship-resistant global &quot;social&quot; network once and for all.
It doesn&#x27;t rely on any trusted central server, hence it is resilient; it is based on cryptographic keys and
signatures, so it is tamperproof; it does not rely on P2P techniques, and therefore it works.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Clients have the option to connect to as many or as few relays as they want, some of which are free and open to the
public, and some of which require payment to access. This allows for a wide variety of communities to coalesce
around certain relays if they choose, and move to another if the one they are using decides to censor them for
any reason.&lt;&#x2F;p&gt;
&lt;p&gt;The implications of this are pretty amazing, and I think it will open up a lot of opportunity in so many directions.
Not only from the standpoint of free speech, but also for relay operators and client developers to build features in
a competitive way, very quickly raising the bar for the network as a whole. We are still very much in the early days,
and things are a little bit crazy, but the hype is real, and I believe for good reason.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;let-s-build-a-client&quot;&gt;Let&#x27;s build a client!&lt;&#x2F;h3&gt;
&lt;p&gt;Besides all the reasons I mentioned above, I&#x27;m excited about nostr, because, as a programmer, I get to &lt;em&gt;build&lt;&#x2F;em&gt; things.
My own things. Things that define how I interact with the network. There are a lot of good clients out there already,
but I figured, &quot;why not try and build my own?&quot;&lt;&#x2F;p&gt;
&lt;p&gt;This is the first entry (index &lt;code&gt;0&lt;&#x2F;code&gt;) in a series of posts I intend to write outlining the basic discovery and process
of building a client. Hopefully we&#x27;ll run into some interesting challenges that need thoughtful solutions, and we&#x27;ll
progress towards something relatively usable.&lt;&#x2F;p&gt;
&lt;p&gt;I&#x27;ll be writing this series as I develop the client (seriously, I haven&#x27;t written a single line of code as I
write this sentence), which is something I&#x27;ve never done before. I&#x27;ll do my best to strike a balance between content
and pace. I don&#x27;t want to dump every single thought in my head out into this post, otherwise it could take hours
to read, but I want to show enough to get an idea of what it takes to build a client at a technical level. I&#x27;ll also
have to stop writing these posts at &lt;em&gt;some&lt;&#x2F;em&gt; point (there&#x27;s more to life, ya know?). But, I&#x27;ll keep developing the
client after I wrap up this series, and anyone can follow along on GitHub once we hit that point.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Hopefully I won&#x27;t give so much detail that it&#x27;s exhausting to read. I&#x27;m hoping I&#x27;ll get better about tightening up
these posts as I go.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Wait, what about the name? After looking at all sorts of weird combinations of &quot;rust&quot; and &quot;nostr&quot;, I came up
with &lt;code&gt;roostr&lt;&#x2F;code&gt;. I like it because it gives the project its own identity, and is actually pronoucable as &quot;rooster&quot;.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;I&#x27;m aware of the whole ostrich thing nostr has going for it. I just wanted some combination of &quot;rust&quot; and &quot;nostr&quot;
and settled on something unique in the space!&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;the-stack&quot;&gt;THE STACK&lt;&#x2F;h3&gt;
&lt;p&gt;I&#x27;ll be writing this client using Rust. That&#x27;s it. That&#x27;s the stack.&lt;&#x2F;p&gt;
&lt;p&gt;It&#x27;ll be a terminal-based client, because frankly it&#x27;s just easier, but I also love the challenge of making a usable
terminal UI. There&#x27;s a neat minimalism there.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;I will definitely assume some Rust knowledge for this series. There are a million ways to learn Rust and I can&#x27;t
really teach it any better. I&#x27;ll make clarifying notes if I think something is particularly odd about Rust that
needs explaining, but I want to keep it to a minimum.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;the-protocol&quot;&gt;The Protocol&lt;&#x2F;h3&gt;
&lt;p&gt;Nostr, as a protocol, is refreshingly simple. The main GitHub &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;nostr-protocol&#x2F;nostr&quot;&gt;repository&lt;&#x2F;a&gt;
is a high-level look at the protocol and motivations behind it, but the NIPs
&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;nostr-protocol&#x2F;nips&quot;&gt;repository&lt;&#x2F;a&gt; is where all the action is.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;nostr-protocol&#x2F;nips&#x2F;blob&#x2F;master&#x2F;01.md&quot;&gt;NIP-01&lt;&#x2F;a&gt; is one of the few mandatory NIPs that relays
and clients must implement, and is the obvious starting point for us. Highly recommend giving it a quick once over
before continuing.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;events&quot;&gt;Events&lt;&#x2F;h4&gt;
&lt;p&gt;Looking at the first available struct defined in NIP-01, let&#x27;s take a stab at defining it in Rust. I want to start
with the event generation and signing portion first, before we start connecting to relays.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub enum &lt;&#x2F;span&gt;&lt;span&gt;Kind {
&lt;&#x2F;span&gt;&lt;span&gt;    SetMetadata,     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; kind: 0
&lt;&#x2F;span&gt;&lt;span&gt;    Text,            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; kind: 1
&lt;&#x2F;span&gt;&lt;span&gt;    RecommendServer, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; kind: 2
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub enum &lt;&#x2F;span&gt;&lt;span&gt;TagId {
&lt;&#x2F;span&gt;&lt;span&gt;    PubKey,  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; tag: &amp;quot;p&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;    Event,   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; tag: &amp;quot;e&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;    Unknown, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ... not sure how to handle this yet
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; simple 3-tuple that will be rendered as a JSON array
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; e.g. [&amp;quot;e&amp;quot;, &amp;quot;&amp;lt;hex&amp;gt;&amp;quot;, &amp;quot;wss:&#x2F;&#x2F;some.relay.net&amp;quot;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Tag(TagId, String, Option&amp;lt;String&amp;gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Event is our core data structure.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; It will likely not be built directly like this, but rather from a function,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; where the `id` will generated and the entire thing (possibly) signed.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Event {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;id&lt;&#x2F;span&gt;&lt;span&gt;: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;pubkey&lt;&#x2F;span&gt;&lt;span&gt;: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;created_at&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: Kind,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;tags&lt;&#x2F;span&gt;&lt;span&gt;: Vec&amp;lt;Tag&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;content&lt;&#x2F;span&gt;&lt;span&gt;: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sig&lt;&#x2F;span&gt;&lt;span&gt;: String,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As noted in the comments, we have some things to figure out as we get further, but for now this gives us a solid
place to stand. It may make more sense to use more specific types for some of these fields, and we will certainly
need to expand upon these, but I want to start simple for now.&lt;&#x2F;p&gt;
&lt;p&gt;Next, we need a way to generate the &lt;code&gt;id&lt;&#x2F;code&gt; for the event.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;To obtain the event.id, we sha256 the serialized event.
The serialization is done over the UTF-8 JSON-serialized string
(with no white space or line breaks) of the following structure:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;[
&lt;&#x2F;span&gt;&lt;span&gt;  0,
&lt;&#x2F;span&gt;&lt;span&gt;  &amp;lt;pubkey, as a (lowercase) hex string&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &amp;lt;created_at, as a number&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &amp;lt;kind, as a number&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &amp;lt;tags, as an array of arrays of non-null strings&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &amp;lt;content, as a string&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;I&#x27;ll be honest, I&#x27;m a little confused by the &quot;with no white space or line breaks&quot; comment. Does that also mean
for the &lt;em&gt;content&lt;&#x2F;em&gt;? I could see it either way, but I&#x27;m going to lean towards we don&#x27;t manipulate the content in any
way to obtain this event &lt;code&gt;id&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Before we can actually sign the event, we need that &lt;code&gt;id&lt;&#x2F;code&gt;, which means we need a method to generate the JSON string
described above, based on the event.&lt;&#x2F;p&gt;
&lt;p&gt;In the Rust world, &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;serde.rs&#x2F;&quot;&gt;&lt;code&gt;serde&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; has become a go-to crate for (ser)ialization, and
(de)serialization, and has support for JSON, so it makes sense for us to start there. &lt;code&gt;serde&lt;&#x2F;code&gt; supports the notion
of a &lt;code&gt;Serialize&lt;&#x2F;code&gt; trait (or &quot;interface&quot;), we can implement to tell &lt;code&gt;serde&lt;&#x2F;code&gt; how we want our custom types to look when
they are represented as JSON. Explaining all the details of &lt;code&gt;serde&lt;&#x2F;code&gt; is definitely outside of the scope of this
post, but this should give you a rough idea.&lt;&#x2F;p&gt;
&lt;p&gt;For &lt;code&gt;Kind&lt;&#x2F;code&gt;, it&#x27;s pretty straightforward, just map each &lt;code&gt;enum&lt;&#x2F;code&gt; variant to a number.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Serialize &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Kind {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;serialize&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;S&amp;gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;serializer&lt;&#x2F;span&gt;&lt;span&gt;: S) -&amp;gt; Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;S::&lt;&#x2F;span&gt;&lt;span&gt;Ok, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;S::&lt;&#x2F;span&gt;&lt;span&gt;Error&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;        S: Serializer,
&lt;&#x2F;span&gt;&lt;span&gt;    {
&lt;&#x2F;span&gt;&lt;span&gt;        serializer.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;serialize_u32&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;match &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            Kind::SetMetadata =&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;            Kind::Text =&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;            Kind::RecommendServer =&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        })
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;Tag&lt;&#x2F;code&gt; type is a little more complicated, since the 3rd element of the array is optional, according to NIP-01.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Serialize &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Tag {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;serialize&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;S&amp;gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;serializer&lt;&#x2F;span&gt;&lt;span&gt;: S) -&amp;gt; Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;S::&lt;&#x2F;span&gt;&lt;span&gt;Ok, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;S::&lt;&#x2F;span&gt;&lt;span&gt;Error&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;        S: Serializer,
&lt;&#x2F;span&gt;&lt;span&gt;    {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; serialize tag
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; tup = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Some(_) = &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            serializer.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;serialize_tuple&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;)?
&lt;&#x2F;span&gt;&lt;span&gt;        } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            serializer.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;serialize_tuple&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;)?
&lt;&#x2F;span&gt;&lt;span&gt;        };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; serialize tag &amp;quot;id&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;        tup.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;serialize_element&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;match &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            TagId::PubKey =&amp;gt; &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;p&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;            TagId::Event =&amp;gt; &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;e&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;            TagId::Unknown =&amp;gt; &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;unknown&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;        })?;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; serialize tag &amp;quot;payload&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;        tup.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;serialize_element&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)?;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; serialize recommended relay (if we have it)
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Some(relay) = &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            tup.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;serialize_element&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;relay)?;
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        tup.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;end&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I&#x27;m sure they are cleaner ways of handling both of these cases, but in the spirit of just getting things working,
let&#x27;s stick with it.&lt;&#x2F;p&gt;
&lt;p&gt;Lastly, we need to consider the &lt;code&gt;Event&lt;&#x2F;code&gt; - the center of all this. I started to go down the route
of implementing &lt;code&gt;Serialize&lt;&#x2F;code&gt; for &lt;code&gt;Event&lt;&#x2F;code&gt;, so it would produce the &lt;code&gt;[0,...]&lt;&#x2F;code&gt; format described above, which we use
in determining the event &lt;code&gt;id&lt;&#x2F;code&gt;, but quickly realized that wouldn&#x27;t be so great.&lt;&#x2F;p&gt;
&lt;p&gt;One thing that&#x27;s really cool about Rust, or even just modern statically typed languages in general, is that we can
encode certain aspects of our problem domain into the types themselves. In this case, &lt;code&gt;EventData&lt;&#x2F;code&gt; is something dynamic,
generated by the user, and can reasonably be &quot;edited&quot;, up until the point we are ready to sign the event for
publication to the network. Once that event is signed though, it doesn&#x27;t make sense that we should be able to edit
that &lt;code&gt;EventData&lt;&#x2F;code&gt; anymore, since changing it necessarily changes the &lt;code&gt;id&lt;&#x2F;code&gt;, which changes the signature
(more on that later).&lt;&#x2F;p&gt;
&lt;p&gt;So, what if our &lt;code&gt;Event&lt;&#x2F;code&gt; type represented this idea directly?&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;derive&lt;&#x2F;span&gt;&lt;span&gt;(serde::Serialize)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Event {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;id&lt;&#x2F;span&gt;&lt;span&gt;: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sig&lt;&#x2F;span&gt;&lt;span&gt;: String,
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    #[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;serde&lt;&#x2F;span&gt;&lt;span&gt;(flatten)]
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;data&lt;&#x2F;span&gt;&lt;span&gt;: EventData, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; this is the old &amp;quot;Event&amp;quot; type, without the id and sig
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;blockquote&gt;
&lt;p&gt;The astute reader might comment that since our &lt;code&gt;Event&lt;&#x2F;code&gt; fields are &quot;pub&quot; here, it doesn&#x27;t actually quite
get us to the point where we have full encapsulation within this module. That&#x27;s something I hope to address
fully, with accessor methods later on.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;With this design in mind, it wouldn&#x27;t make sense to write &lt;code&gt;Serialize&lt;&#x2F;code&gt; for &lt;code&gt;EventData&lt;&#x2F;code&gt; in such a way that doesn&#x27;t result in
the standard JSON representation of the struct, which we want to send over the wire to the relays. We want to lean
on &lt;code&gt;serde&lt;&#x2F;code&gt;&#x27;s provided implemention of &lt;code&gt;Serialize&lt;&#x2F;code&gt; for structs, and include the fields of &lt;code&gt;EventData&lt;&#x2F;code&gt; into our final
&lt;code&gt;Event&lt;&#x2F;code&gt; JSON representation, at the same level as &lt;code&gt;id&lt;&#x2F;code&gt; and &lt;code&gt;sig&lt;&#x2F;code&gt; (hence the &lt;code&gt;flatten&lt;&#x2F;code&gt; directive). So, we can&#x27;t
use &lt;code&gt;Serialize&lt;&#x2F;code&gt; to build our array for determining the event &lt;code&gt;id&lt;&#x2F;code&gt;. We&#x27;ll have to write a simple function to do that
using string formatting.&lt;&#x2F;p&gt;
&lt;p&gt;OK! That was a bit of a detour, but hopefully a fruitful one. Here&#x27;s what we have now for &lt;code&gt;EventData&lt;&#x2F;code&gt; and &lt;code&gt;Event&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;derive&lt;&#x2F;span&gt;&lt;span&gt;(serde::Serialize)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;EventData {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;pubkey&lt;&#x2F;span&gt;&lt;span&gt;: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;created_at&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: Kind,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;tags&lt;&#x2F;span&gt;&lt;span&gt;: Vec&amp;lt;Tag&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;content&lt;&#x2F;span&gt;&lt;span&gt;: String,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;EventData {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;id&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; String {
&lt;&#x2F;span&gt;&lt;span&gt;        hex::encode(
&lt;&#x2F;span&gt;&lt;span&gt;            Sha256::new()
&lt;&#x2F;span&gt;&lt;span&gt;                .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;chain_update&lt;&#x2F;span&gt;&lt;span&gt;(format!(
&lt;&#x2F;span&gt;&lt;span&gt;                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; just lean on serde here as well, for each element.
&lt;&#x2F;span&gt;&lt;span&gt;                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; makes the format string nicer to look at
&lt;&#x2F;span&gt;&lt;span&gt;                    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;[0,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;]&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;                    json::to_string(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.pubkey).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;(),
&lt;&#x2F;span&gt;&lt;span&gt;                    json::to_string(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.created_at).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;(),
&lt;&#x2F;span&gt;&lt;span&gt;                    json::to_string(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.kind).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;(),
&lt;&#x2F;span&gt;&lt;span&gt;                    json::to_string(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.tags).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;(),
&lt;&#x2F;span&gt;&lt;span&gt;                    json::to_string(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.content).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;(),
&lt;&#x2F;span&gt;&lt;span&gt;                ))
&lt;&#x2F;span&gt;&lt;span&gt;                .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;finalize&lt;&#x2F;span&gt;&lt;span&gt;(),
&lt;&#x2F;span&gt;&lt;span&gt;        )
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Event can only be generated from EventData,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; with a provided key for signing.
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;derive&lt;&#x2F;span&gt;&lt;span&gt;(serde::Serialize)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Event {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;id&lt;&#x2F;span&gt;&lt;span&gt;: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sig&lt;&#x2F;span&gt;&lt;span&gt;: String,
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    #[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;serde&lt;&#x2F;span&gt;&lt;span&gt;(flatten)]
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;data&lt;&#x2F;span&gt;&lt;span&gt;: EventData,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now, we can create a simple test case for &lt;code&gt;EventData&lt;&#x2F;code&gt;, and make sure we are getting some &lt;code&gt;id&lt;&#x2F;code&gt; back from it.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;test&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;event_id&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; sample event
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; https:&#x2F;&#x2F;www.nostr.guru&#x2F;e&#x2F;c8d24e78cfedd658688bdfc23a2f7049f0032989096f3e1c5df1e5585efaa393
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; data = EventData {
&lt;&#x2F;span&gt;&lt;span&gt;        pubkey: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;5fe74dc9a7349be18269007d8e7bdf7599869cb677fe3f2794ebd821f146fe81&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;into&lt;&#x2F;span&gt;&lt;span&gt;(),
&lt;&#x2F;span&gt;&lt;span&gt;        created_at: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1675631070&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        kind: Kind::Text,
&lt;&#x2F;span&gt;&lt;span&gt;        tags: vec![],
&lt;&#x2F;span&gt;&lt;span&gt;        content: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;hello, nostr&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;into&lt;&#x2F;span&gt;&lt;span&gt;(),
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    assert_eq!(
&lt;&#x2F;span&gt;&lt;span&gt;        data.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;id&lt;&#x2F;span&gt;&lt;span&gt;(),
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;c8d24e78cfedd658688bdfc23a2f7049f0032989096f3e1c5df1e5585efaa393&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;    );
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;signatures&quot;&gt;Signatures&lt;&#x2F;h4&gt;
&lt;p&gt;The next critical piece we need to consider is signing the events with a key pair.&lt;&#x2F;p&gt;
&lt;p&gt;By utilizing digital signatures, nostr clients and relays can verify the integrity of messages. They are the core piece
of a user&#x27;s identity as they move from one relay to another. This what people mean when they say nostr is
&quot;tamperproof&quot;. As long as you practice secure handling of your keys, no one can generate fake events associated with
your public key.&lt;&#x2F;p&gt;
&lt;p&gt;As stated in the NIP-01 specification,&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Each user has a keypair. Signatures, public key, and encodings are done according to the Schnorr signatures
standard for the curve secp256k1.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;The whole cryptography thing is a &lt;em&gt;h u g e&lt;&#x2F;em&gt; topic to cover, and I am by no means an expert, so I won&#x27;t go into much
detail. The basic idea is that everybody has a public key and a private key. This is called the &quot;key pair&quot;.
A user can &quot;sign&quot; data with their private key, and share their public key with the world. Anybody can then look
at the signature data, and verify it was in fact signed by the user with the associated public key, all without
revealing the private key itself, so it can be re-used.&lt;&#x2F;p&gt;
&lt;p&gt;Fortunately, there is a lot of prior art out there we can utilize to get this working pretty easily.&lt;&#x2F;p&gt;
&lt;p&gt;I&#x27;ll be using the &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;secp256k1&#x2F;latest&#x2F;secp256k1&#x2F;index.html&quot;&gt;&lt;code&gt;secp256k1&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; crate, which has support
for Schnorr signatures as well. We&#x27;ll also need the &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;bech32&#x2F;0.9.1&#x2F;bech32&#x2F;&quot;&gt;&lt;code&gt;bech32&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; crate to
support encoding and decoding of keys in a user-friendly way.&lt;&#x2F;p&gt;
&lt;p&gt;First, let&#x27;s build the signing context and key pair, by reading a value from the environment. Nostr keys use the &lt;code&gt;bech32&lt;&#x2F;code&gt;
encoding, so private keys begin with &lt;code&gt;nsec1&lt;&#x2F;code&gt; and public keys begin with &lt;code&gt;npub1&lt;&#x2F;code&gt;. This makes it easier for a human
looking at values to know which they are dealing with. The public key can be derived from the private key, so we
only need to include the latter in our configuration.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;derive&lt;&#x2F;span&gt;&lt;span&gt;(Parser, Debug)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Config {
&lt;&#x2F;span&gt;&lt;span&gt;    #[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;clap&lt;&#x2F;span&gt;&lt;span&gt;(env = &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;ROOSTR_PRIVATE_KEY&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;)]
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;key&lt;&#x2F;span&gt;&lt;span&gt;: SecretString,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Signer {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;context&lt;&#x2F;span&gt;&lt;span&gt;: Secp256k1&amp;lt;All&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;keypair&lt;&#x2F;span&gt;&lt;span&gt;: KeyPair,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Signer {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;from_config&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;config&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;Config) -&amp;gt; anyhow::Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; decode `nsec1...` into Vec&amp;lt;u5&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;(_, decoded, _) = bech32::decode(&amp;amp;config.key.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;expose_secret&lt;&#x2F;span&gt;&lt;span&gt;())?;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; create Vec&amp;lt;u8&amp;gt; from Vec&amp;lt;u5&amp;gt; (&amp;quot;base32&amp;quot;)
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; bytes: Vec&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; = Vec::from_base32(&amp;amp;decoded)?;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; generate a secret key on the curve from the byte vector
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; context = Secp256k1::new();
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; key = SecretKey::from_slice(&amp;amp;bytes)?;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; keypair = KeyPair::from_secret_key(&amp;amp;context, &amp;amp;key);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        Ok(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{ context, keypair })
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    ...
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;blockquote&gt;
&lt;p&gt;From a security standpoint, this isn&#x27;t ready for production. I&#x27;m currently doing just about the bare minimum here
in order to get this working, by using this &lt;code&gt;SecretString&lt;&#x2F;code&gt; type imported from the &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;secrecy&#x2F;0.8.0&#x2F;secrecy&#x2F;&quot;&gt;&lt;code&gt;secrecy&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;
crate, which basically just zeros out the memory allocation when the value&#x27;s memory is freed, and makes it very explicit
when we expose the secret value to other functions. We&#x27;ll revisit this topic of key management in a later post.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Now that we have that, we can write the function that will sign our event &lt;code&gt;id&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Signer {
&lt;&#x2F;span&gt;&lt;span&gt;    ...
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; public key returned in the &amp;quot;x only&amp;quot; format,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; which drops the first parity byte
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;public_key&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; String {
&lt;&#x2F;span&gt;&lt;span&gt;        format!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{:x}&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.keypair.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;x_only_public_key&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;sign&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;id&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;str&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; anyhow::Result&amp;lt;String&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; message = Message::from_slice(&amp;amp;hex::decode(id)?)?;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; signature = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.context.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;sign_schnorr&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;message, &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.keypair);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        Ok(format!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{signature:x}&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;))
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I had to find the &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;secp256k1&#x2F;latest&#x2F;secp256k1&#x2F;struct.KeyPair.html#method.x_only_public_key&quot;&gt;&lt;code&gt;KeyPair::x_only_public_key&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;
function after I had originally just tried to test with &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;secp256k1&#x2F;latest&#x2F;secp256k1&#x2F;struct.KeyPair.html#method.public_key&quot;&gt;&lt;code&gt;KeyPair::public_key&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;
which seems to include some kind of &quot;parity&quot; byte at the front of the hex output. I can&#x27;t see that being relevant
when looking at the raw data of other valid nostr events out in the wild, so I don&#x27;t think it&#x27;s necessary. This makes
sense actually when we see that &quot;X only&quot; intends the key to be used only for signature verification.&lt;&#x2F;p&gt;
&lt;p&gt;Finally, we can put our types together in the way we described above to generate a signed &lt;code&gt;Event&lt;&#x2F;code&gt; from &lt;code&gt;EventData&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;derive&lt;&#x2F;span&gt;&lt;span&gt;(serde::Serialize)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;EventData {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;created_at&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;: Kind,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;tags&lt;&#x2F;span&gt;&lt;span&gt;: Vec&amp;lt;Tag&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;content&lt;&#x2F;span&gt;&lt;span&gt;: String,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;EventData {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;id&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;pubkey&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;str&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; String {
&lt;&#x2F;span&gt;&lt;span&gt;        hex::encode(
&lt;&#x2F;span&gt;&lt;span&gt;            Sha256::new()
&lt;&#x2F;span&gt;&lt;span&gt;                .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;chain_update&lt;&#x2F;span&gt;&lt;span&gt;(format!(
&lt;&#x2F;span&gt;&lt;span&gt;                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; just lean on serde here as well, for each element.
&lt;&#x2F;span&gt;&lt;span&gt;                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; makes the format string nicer to look at
&lt;&#x2F;span&gt;&lt;span&gt;                    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;[0,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;]&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;                    json::to_string(&amp;amp;pubkey).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;(),
&lt;&#x2F;span&gt;&lt;span&gt;                    json::to_string(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.created_at).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;(),
&lt;&#x2F;span&gt;&lt;span&gt;                    json::to_string(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.kind).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;(),
&lt;&#x2F;span&gt;&lt;span&gt;                    json::to_string(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.tags).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;(),
&lt;&#x2F;span&gt;&lt;span&gt;                    json::to_string(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.content).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;(),
&lt;&#x2F;span&gt;&lt;span&gt;                ))
&lt;&#x2F;span&gt;&lt;span&gt;                .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;finalize&lt;&#x2F;span&gt;&lt;span&gt;(),
&lt;&#x2F;span&gt;&lt;span&gt;        )
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;sign&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;signer&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;Signer) -&amp;gt; anyhow::Result&amp;lt;Event&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; pubkey = signer.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;public_key&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; id = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;id&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;pubkey);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; sig = signer.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;sign&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;id)?;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        Ok(Event {
&lt;&#x2F;span&gt;&lt;span&gt;            id,
&lt;&#x2F;span&gt;&lt;span&gt;            sig,
&lt;&#x2F;span&gt;&lt;span&gt;            pubkey,
&lt;&#x2F;span&gt;&lt;span&gt;            data: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        })
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;You may notice, I also changed up the the type definitions a little bit here. I found it a bit awkward to have the
&lt;code&gt;pubkey&lt;&#x2F;code&gt; of the signing key pair on the &lt;code&gt;EventData&lt;&#x2F;code&gt; struct. So instead, I added it as a parameter to the &lt;code&gt;id()&lt;&#x2F;code&gt;
generation function, which is then utilized in the &lt;code&gt;sign()&lt;&#x2F;code&gt; function. This all seemed a bit cleaner to me,
as I really only have to give the signing &quot;context&quot; &lt;em&gt;once&lt;&#x2F;em&gt; when &lt;code&gt;EventData&lt;&#x2F;code&gt; is actually signed and produces
an &lt;code&gt;Event&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;It&#x27;s also worthwhile to note some Rust semantics here. In the &lt;code&gt;sign()&lt;&#x2F;code&gt; function signature (no pun intended), there&#x27;s
this &lt;code&gt;self&lt;&#x2F;code&gt; parameter, which doesn&#x27;t include the more common &lt;code&gt;&amp;amp;&lt;&#x2F;code&gt;, or immutable reference. In this case, we
actually want the &lt;code&gt;sign()&lt;&#x2F;code&gt; function to take &quot;ownership&quot; of the &lt;code&gt;EventData&lt;&#x2F;code&gt;, consuming it in a such a way that prevents
the caller from using &lt;em&gt;their&lt;&#x2F;em&gt; reference to it anymore, which helps us to encode this idea that once you sign &lt;code&gt;EventData&lt;&#x2F;code&gt;,
it really shouldn&#x27;t be modified anymore.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;the-result&quot;&gt;The Result&lt;&#x2F;h4&gt;
&lt;p&gt;Finally, we can generate a fully valid nostr &lt;code&gt;Event&lt;&#x2F;code&gt;!&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;clap::Parser;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;roostr::event::{Kind, EventData};
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;roostr::signature::Signer;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;roostr::Config;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;main&lt;&#x2F;span&gt;&lt;span&gt;() -&amp;gt; anyhow::Result&amp;lt;()&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    dotenv::dotenv().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;ok&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; config = Config::parse();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; signer = Signer::from_config(&amp;amp;config)?;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; data = EventData {
&lt;&#x2F;span&gt;&lt;span&gt;        created_at: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1678648700&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        kind: Kind::Text,
&lt;&#x2F;span&gt;&lt;span&gt;        tags: vec![],
&lt;&#x2F;span&gt;&lt;span&gt;        content: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;hello, reader!&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;into&lt;&#x2F;span&gt;&lt;span&gt;(),
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; event = data.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;sign&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;signer)?;
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{:#?}&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, event);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    Ok(())
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let&#x27;s &lt;code&gt;cargo run&lt;&#x2F;code&gt; that.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;Event {
&lt;&#x2F;span&gt;&lt;span&gt;    id: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;bba6b589e2cc685eb26b5558184ed3022bc5181364d16b83be73410d37fed84e&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    sig: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;c91c91e86b6359e5ba364cd40450886ed3f34e0b7a0f5765c23f8426390ff5e23ac2c7846a351bca62b18482414a2dea7d09051b20745ff9107f11e8320a8ea7&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    pubkey: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;e241ea8967a43f8c67eff8b16311a204fcc50906e5c2c5c87d1ec7422ea1a6d5&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    data: EventData {
&lt;&#x2F;span&gt;&lt;span&gt;        created_at: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1679855436&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        kind: Text,
&lt;&#x2F;span&gt;&lt;span&gt;        tags: [],
&lt;&#x2F;span&gt;&lt;span&gt;        content: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;hello, reader!&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    },
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;next-up&quot;&gt;Next Up&lt;&#x2F;h3&gt;
&lt;p&gt;I do plan on releasing this on GitHub in the near future. Once I have simple relay interaction working, I think it&#x27;ll
make sense to do so. Part of this exercise is for my own learning experience as well, so I&#x27;m not quite ready to accept
pull requests just yet.&lt;&#x2F;p&gt;
&lt;p&gt;In the next post in this series, we&#x27;ll look at connecting to relays, and building a simple user interface to read
messages from those relays.&lt;&#x2F;p&gt;
</content>
        
    </entry>
</feed>
